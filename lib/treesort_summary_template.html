<html>
<head>
   <style>
      
      .treesort-page {
         font-family: "Helvetica Neue", Helvetica, Aria;
         line-height: 1.5rem;
         max-width: 900px;
         padding: 1.0rem;
      }

      .treesort-page hr {
         border-color: rgba(127, 127, 127, 0.2);
      }

      .treesort--title {
         margin-bottom: 2.0rem;
      }

      .treesort--section-title {
         border-color: rgba(127, 127, 127, 0.2);
         border-style: solid;
         border-width: 0 0 1px 0;
         width: 100%;
      }

      .treesort--background-info {
         margin-bottom: 2.0rem;
      }

      /*.treesort--inline-details {
         margin: 0 0 0 0.5rem;
      }*/

      .treesort--section-body {
         margin-bottom: 2.0rem;
      }
      .treesort--section-body ul {
         padding-left: 1.5rem;
      }
      .treesort--section-body li {
         margin-bottom: 0.5rem;
      }

      .treesort--segment-title {
         margin-bottom: 0.25rem;
      }

      /* The table of segment-specific file data. */
      .treesort--segment-table {
         border-collapse: collapse;
         font-family: sans-serif;
         font-size: 0.95rem;
         margin: 0.5rem 0 1.5rem 0;
         text-align: left;
         width: 100%;
      }
      .treesort--segment-table th, .treesort--segment-table td {
         border: 1px solid #ccc;
         padding: 0.75em 1em;
      }
      .treesort--segment-table th {
         background-color: #f5f5f5;
         font-weight: bold;
      }
      .treesort--segment-table th.treesort--file {
         width: 40%;
      }

      .treesort--segment-table tr:nth-child(even) {
      background-color: #f9f9f9;
      }
      .treesort--segment-table tr:hover {
         background-color: #f1f1f1;
      }

   </style>
</head>
<body>
   <div class="treesort-page">
      <h1 class="treesort--title">TreeSort Analysis Results</h1>

      <h3>About the results</h3>
      <div class="treesort--background-info">TreeSort can accurately identify recent and ancestral reassortment events on datasets with thousands of genomes. 
         Using the phylogeny of a selected segment as a reference and information from other gene segments, TreeSort finds the branches in the phylogeny 
         where reassortment is most likely to have occurred, reports the particular gene segments involved in reassortment, and lists their differences from 
         prior gene pairings.
      </div>

      <h2 class="treesort--section-title">Summary</h2>
      <div class="treesort--section-body">
         TreeSort provided the following summary of its parameters and analysis:
         <div id="treesort_summary"></div>
      </div>

      <h2 class="treesort--section-title">Result files</h2>

      <h3>Reassortment summary: <span id="treesort_reassortments_file"></span></h3>
      <div class="treesort--section-body">The TreeSort service parses the annotations in the tree file and generates a downloadable summary of all strains where 
         reassortment is suspected. The reassortment summary file is a CSV file with the following columns:<br/>
         <ul>
            <li><b>strain</b>: The name of the strain from the FASTA header/defline</li>
            <li><b>is_reassorted</b>: If a reassortment was inferred for this strain, this column will contain "Y".</li>
            <li><b>is_uncertain</b>: If the reassortment placement is uncertain, this column will contain "Y". <br/><br/>
               <div class="treesort--inline-details">TreeSort does not have enough information to confidently place a reassortment event on a specific branch of the tree. 
               TreeSort always narrows down the reassortment event to a particular ancestral node on a tree, but may not distinguish which of the child branches 
               was affected by reassortment. In those cases, TreeSort will annotate both child branches in the annotated tree file with a ?&lt;segment-name&gt; tag. 
               For example, ?PB2(26) below indicates that the reassortment with PB2 might have happened on either of the child branches.<br/><br/>
               Note that this section only applies to the "local" inference method (the default method for TreeSort). The "mincut" method always infers certain 
               reassortment placements.</div>
            </li>
            <li><b>Segment columns</b>: The remaining columns correspond to the segments that were included in the analysis. If a segment was inferred to be reassorted, 
               the column for that segment will contain the number of nucleotide differences between the reassorted segment and the closest prior relative.
            </li>
         </ul>
      </div>

      <h3>Tree file (PhyloXML): <span id="treesort_phyloxml_file"></span></h3>
      <div class="treesort--section-body">The annotated tree file in <a href="https://www.phyloxml.org/" target="_blank">PhyloXML</a> format. When viewed in our 
         tree visualization tool (Archaeopteryx), you can customize the display to highlight nodes with inferred reassortment by segment. Internal nodes with reassortment
         are labeled with the segment and nucleotide distance (ex. "PB2(124)"), and the reassorted strain names have this label as a prefix (ex. "NA(169): A/swine/North_Carolina/A01894897/2016|1B.2.1|2002B|TTTTPT|2016-04-06").
      </div>
      
      <h3>Tree file (Nexus): <span id="treesort_nexus_file"></span></h3>
      <div class="treesort--section-body">The original tree file generated by TreeSort in Nexus format.</div>

      <h2 class="treesort--section-title">Segment-specific files</h2>
      <div class="treesort--section-body">
         <b>Background</b>: In the segment-specific files, "Root-to-tip" regression data provides insight into the quality of the phylogenetic tree that was generated 
         and includes several indicators:
         <ul>
            <li>The <b>R<sup>2</sup></b> value indicates the fraction of variation in root-to-tip distance explained by the sampling times. Higher values 
               correspond to more clock-like behavior (max 1.0).</li>
            <li>The <b>rate</b> is the slope of the best fit of the date to the root-to-tip distance and provides an estimate of the substitution rate. Note that
               the rate needs to be positive, as negative rates suggest an inappropriate root.</li>
            <li>The estimated rate and tree correspond to a <b>root date</b></li>
         </ul>
      </div>

      <div id="treesort_segment_files"></div>
   </div>

   <script type="text/javascript">

      // File types used in the Workspace browser.
      const FileType = {
         aln: "aln", // TODO: Is this a valid file type?
         csv: "csv",
         nwk: "nwk",
         pdf: "pdf",
         phyloxml: "phyloxml",
         tsv: "tsv"
      }

      // The current page's base URL.
      const baseURL = window.location.origin;

      // Variables populated by run_treesort.py.
      const nexusFilename = "{{nexus_filename}}";
      const phyloXmlFilename = "{{phyloxml_filename}}";
      const outputSubdirectory = "{{output_subdirectory}}";
      const reassortmentsFilename = "{{reassortments_filename}}";
      const resultsJSON = "{{results_json}}";
      const segmentList = "{{segments}}";
      const treesortSummary = "{{treesort_summary}}";
      const workspaceFolder = "{{workspace_folder}}";

      // Split the segment list into an array.
      let segments = segmentList.split(",");

      const segmentFiles = [
         { label: "Alignment", suffix: "-input.fasta.aln", description: "The alignment file", type: FileType.aln },
         { label: "Dates", suffix: "-input.fasta.aln.dates.csv", description: "Dates found in the FASTA deflines", type: FileType.csv },
         { label: "Rooted tree", suffix: "-input.fasta.aln.rooted.tre", description: "The rooted tree file", type: FileType.nwk },
         { label: "Tree", suffix: "-input.fasta.tre", description: "The tree file", type: FileType.nwk },
         { label: "Outliers", suffix: "-input.fasta.aln.treetime/outliers.tsv", description: "A table of outlier data", type: FileType.tsv },
         { label: "Root to tip regression", suffix: "-input.fasta.aln.treetime/root_to_tip_regression.pdf", 
            description: "A visualization of root-to-tip regression", type: FileType.pdf },
         { label: "Root to tip data", suffix: "-input.fasta.aln.treetime/rtt.csv", description: "The root-to-tip data in CSV format. Note that dates of nodes that " + 
            "didn't have a specified date are inferred from the root-to-tip regression.", type: FileType.csv }
      ]

      // Create the appropriate type of link based on the file type.
      function createFileLink(filePath_, fileType_, label_) {

         if (!filePath_ || !fileType_ || !label_ || !FileType.hasOwnProperty(fileType_)) { return "(file unavailable)"; }

         let url = "";

         switch (fileType_) {
            case FileType.phyloxml:

               // Create a link to Archaeopteryx. Note that the "treeSort=true" parameter enables TreeSort-specific features in the viewer.
               url = `${baseURL}/view/PhylogeneticTree2/?labelSearch=false&idType=genome_id&labelType=genome_name&wsTreeFile=${filePath_}&fileType=phyloxml&treeSort=true`;
               break;
            default:
               url = `${baseURL}/workspace/${filePath_}`;
               break;
         }

         return `<a href="${url}" target="_blank">${label_}</a>`;
      }

      // Get the segment summary from the JSON.
      function getSegmentSummary(segment_) {

         if (!resultsJSON || !resultsJSON.segments) { return ""; }

         const messages = resultsJSON.segments[segment_];
         if (!Array.isArray(messages) || messages.length < 1) { return ""; }

         let list = "";

         messages.forEach((message_) => {
            list += `<li>${message_}</li>`;
         })
            
         return `<ul>${list}</ul>`;
      }

      // Update placeholder text on the page.
      function populatePage() {

         // Get a reference to the Nexus file element and populate it.
         const nexusFileEl = document.getElementById("treesort_nexus_file");
         if (nexusFileEl) { 
            nexusFileEl.innerHTML = !nexusFilename ? "(file unavailable)" : createFileLink(`${workspaceFolder}${nexusFilename}`, FileType.nwk, nexusFilename);
         }

         // Get a reference to the PhyloXML file element and populate it.
         const phyloXmlFileEl = document.getElementById("treesort_phyloxml_file");
         if (phyloXmlFileEl) {
            phyloXmlFileEl.innerHTML = !phyloXmlFilename ? "(file unavailable)" : createFileLink(`${workspaceFolder}${phyloXmlFilename}`, FileType.phyloxml, phyloXmlFilename);
         }
 
         // Get a reference to the "reassortments file" element and populate it.
         const reassortmentsEl = document.getElementById("treesort_reassortments_file");
         if (reassortmentsEl) {
            reassortmentsEl.innerHTML = !reassortmentsFilename ? "(file unavailable)" : createFileLink(`${workspaceFolder}${reassortmentsFilename}`, FileType.csv, reassortmentsFilename);
         }
         
         // Get a reference to the TreeSort summary element and populate it.
         const summaryEl = document.getElementById("treesort_summary");
         if (summaryEl) { 
            summaryEl.innerHTML = !treesortSummary ? "No summary is available" : treesortSummary;
         }

         // Populate the section with segment-specific results.
         populateResultsBySegment();
      }


      // Populate the section with segment-specific results.
      function populateResultsBySegment() {

         // Get a reference to the "results by segment" element.
         const resultsBySegmentEl = document.getElementById("treesort_segment_files");
         if (!resultsBySegmentEl) { return; }
            
         // Was segment data provided?
         if (!segments || segments.length < 1) { 
            resultsBySegmentEl.innerHTML = "No segments were analyzed";
            return;
         }
         
         let html = "";

         // Iterate over all segments that were included in the analysis.
         segments.forEach((segment_, index_) => {

            let rowsHTML = "";

            // Trim and validate the segment name.
            segment_ = segment_.trim();
            if (!segment_ || segment_.length < 1) { return; }

            // Try to get the segment summary from the JSON.
            const summaryHTML = getSegmentSummary(segment_);
            if (summaryHTML.length < 1) {
               html += `<div class="no-results">No data is available</div>`;
               return;
            }

            // Display the root-to-tip regression summary and PDF.
            html += `<h3 class="treesort--segment-title">${segment_} root-to-tip (RTT) regression</h3>
               <div class="treesort--section-body">
                  ${summaryHTML}
                  <div style="width: 640px; height: 480px;">
                     <embed src="${outputSubdirectory}/${segment_}-input.fasta.aln.treetime/root_to_tip_regression.pdf" type="application/pdf" width="100%" height="100%" />
                  </div>
               </div>`;
            
            // Create table rows for the linked files.
            segmentFiles.forEach((file_, index_) => {

               // Alternate row classes
               const rowClass = index_ % 2 ? "treesort--even" : "treesort--odd";

               let fileLink = createFileLink(`${workspaceFolder}${outputSubdirectory}/${segment_}${file_.suffix}`, file_.type, `${segment_}${file_.suffix}`);
               
               // Create a row for this file.
               rowsHTML += `<tr class="${rowClass}">
                  <td>${fileLink}</td>
                  <td>${file_.description}</td>
               </tr>`;
            })

            html += `<h3 class="treesort--segment-title">${segment_} files</h3>
               <table class="treesort--segment-table">
                  <thead>
                     <tr>
                        <th class="treesort--file">File</th>
                        <th>Description</th>
                     </tr>
                  </thead>
                  <tbody>${rowsHTML}</tbody>
               </table>`;
         })

         resultsBySegmentEl.innerHTML = html;
      }

      window.addEventListener('load', function() {
         populatePage();
      })
      
   </script>
</body>
</html>