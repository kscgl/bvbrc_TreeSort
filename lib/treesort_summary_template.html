<html>
<head>
   <style>
      
      .treesort-page {
         font-family: "Helvetica Neue", Helvetica, Aria;
         line-height: 1.5rem;
         max-width: 900px;
         padding: 1.0rem;
      }

      .treesort-page hr {
         border-color: rgba(127, 127, 127, 0.2);
      }

      .treesort--title {
         margin-bottom: 2.0rem;
      }

      .treesort--section-title {
         border-color: rgba(127, 127, 127, 0.2);
         border-style: solid;
         border-width: 0 0 1px 0;
         width: 100%;
      }

      .treesort--background-info {
         margin-bottom: 2.0rem;
      }

      /*.treesort--inline-details {
         margin: 0 0 0 0.5rem;
      }*/

      .treesort--section-body {
         margin-bottom: 2.0rem;
      }
      .treesort--section-body ul {
         padding-left: 1.5rem;
      }
      .treesort--section-body li {
         margin-bottom: 0.5rem;
      }

      .treesort--segment-title {
         margin-bottom: 0.25rem;
      }

      /* The table of segment-specific file data. */
      .treesort--segment-table {
         border-collapse: collapse;
         font-family: sans-serif;
         font-size: 0.95rem;
         margin: 0.5rem 0 1.5rem 0;
         text-align: left;
         width: 100%;
      }
      .treesort--segment-table th, .treesort--segment-table td {
         border: 1px solid #ccc;
         padding: 0.75em 1em;
      }
      .treesort--segment-table th {
         background-color: #f5f5f5;
         font-weight: bold;
      }
      .treesort--segment-table th.treesort--file {
         width: 40%;
      }

      .treesort--segment-table tr:nth-child(even) {
      background-color: #f9f9f9;
      }
      .treesort--segment-table tr:hover {
         background-color: #f1f1f1;
      }

   </style>
</head>
<body>
   <div class="treesort-page">
      <h1 class="treesort--title">TreeSort Analysis Results</h1>

      <h3>About the results</h3>
      <div class="treesort--background-info">TreeSort can accurately identify recent and ancestral reassortment events on datasets with thousands of genomes. 
         Using the phylogeny of a selected segment as a reference and information from other gene segments, TreeSort finds the branches in the phylogeny 
         where reassortment is most likely to have occurred, reports the particular gene segments involved in reassortment, and lists their differences from 
         prior gene pairings.
      </div>

      <h2 class="treesort--section-title">Summary</h2>
      <div class="treesort--section-body">
         TreeSort provided the following summary of its parameters and analysis:
         <div id="treesort_summary"></div>
      </div>

      <h2 class="treesort--section-title">Result files</h2>

      <h3>Annotated tree: <span id="treesort_output_file"></span></h3>
      <div class="treesort--section-body">The primary result of the analysis is an annotated tree file. 
         Information about reassorted segments is displayed at the associated nodes (strains) in the tree visualization.
      </div>
      
      <h3>Reassortment summary: <span id="treesort_reassortments_file"></span></h3>
      <div class="treesort--section-body">The TreeSort service parses the annotations in the tree file and generates a downloadable summary of all strains where 
         reassortment is suspected. The reassortment summary file is a CSV file with the following columns:<br/>
         <ul>
            <li><b>strain</b>: The name of the strain from the FASTA header/defline</li>
            <li><b>is_reassorted</b>: If a reassortment was inferred for this strain, this column will contain "Y".</li>
            <li><b>is_uncertain</b>: If the reassortment placement is uncertain, this column will contain "Y". <br/><br/>
               <div class="treesort--inline-details">TreeSort does not have enough information to confidently place a reassortment event on a specific branch of the tree. 
               TreeSort always narrows down the reassortment event to a particular ancestral node on a tree, but may not distinguish which of the child branches 
               was affected by reassortment. In those cases, TreeSort will annotate both child branches in the annotated tree file with a ?&lt;segment-name&gt; tag. 
               For example, ?PB2(26) below indicates that the reassortment with PB2 might have happened on either of the child branches.<br/><br/>
               Note that this section only applies to the "local" inference method (the default method for TreeSort). The "mincut" method always infers certain 
               reassortment placements.</div>
            </li>
            <li><b>Segment columns</b>: The remaining columns correspond to the segments that were included in the analysis. If a segment was inferred to be reassorted, 
               the column for that segment will contain the number of nucleotide differences between the reassorted segment and the closest prior relative.
            </li>
         </ul>
         
      </div>

      <h2 class="treesort--section-title">Segment-specific files</h2>
      <div class="treesort--section-body">
         <b>Background</b>: In the segment-specific files, "Root-to-tip" regression data provides insight into the quality of the phylogenetic tree that was generated 
         and includes several indicators:
         <ul>
            <li>The <b>R<sup>2</sup></b> value indicates the fraction of variation in root-to-tip distance explained by the sampling times. Higher values 
               correspond to more clock-like behavior (max 1.0).</li>
            <li>The <b>rate</b> is the slope of the best fit of the date to the root-to-tip distance and provides an estimate of the substitution rate. Note that
               the rate needs to be positive, as negative rates suggest an inappropriate root.</li>
            <li>The estimated rate and tree correspond to a <b>root date</b></li>
         </ul>
      </div>

      <div id="treesort_segment_files"></div>
   </div>

   <script type="text/javascript">

      // Variables populated by run_treesort.py.
      const outputSubdirectory = "{{output_subdirectory}}";
      const reassortmentsFilename = "{{reassortments_filename}}";
      const resultFilename = "{{result_filename}}";
      const resultsJSON = "{{results_json}}";
      const segmentList = "{{segments}}";
      const treesortSummary = "{{treesort_summary}}";
      const workspaceFolder = "{{workspace_folder}}";

      // Split the segment list into an array.
      let segments = segmentList.split(",");

      const segmentFiles = [
         { label: "Alignment", path: "-input.fasta.aln", description: "The alignment file"},
         { label: "Dates", path: "-input.fasta.aln.dates.csv", description: "Dates found in the FASTA deflines"},
         { label: "Rooted tree", path: "-input.fasta.aln.rooted.tre", description: "The rooted tree file"},
         { label: "Tree", path: "-input.fasta.tre", description: "The tree file"},

         { label: "Outliers", path: "-input.fasta.aln.treetime/outliers.tsv", description: "A table of outlier data"},
         { label: "Root to tip regression", path: "-input.fasta.aln.treetime/root_to_tip_regression.pdf", description: "A visualization of root-to-tip regression"},
         { label: "Root to tip data", path: "-input.fasta.aln.treetime/rtt.csv", description: "Tbe root-to-tip data in CSV format"}
      ]


      // Get the segment summary from the JSON.
      function getSegmentSummary(segment_) {

         if (!resultsJSON || !resultsJSON.segments) { return ""; }

         const messages = resultsJSON.segments[segment_];
         if (!Array.isArray(messages) || messages.length < 1) { return ""; }

         let list = "";

         messages.forEach((message_) => {
            list += `<li>${message_}</li>`;
         })
            
         return `<ul>${list}</ul>`;
      }


      // Update placeholder text on the page.
      function populatePage() {

         // Get a reference to the output file element.
         const outputFileEl = document.getElementById("treesort_output_file");
         if (outputFileEl) { 
            // Add a link to the output file (the annotated tree file).
            outputFileEl.innerHTML = `<a href="/view/PhylogeneticTree2/?wsTreeFile=${workspaceFolder}${resultFilename}&fileType=nwk" target="_blank">${resultFilename}</a>`;
         }

         // Get a reference to the "reassortments file" element.
         const reassortmentsEl = document.getElementById("treesort_reassortments_file");
         if (reassortmentsEl) { 
            // Add a link to the reassortments summary CSV file.
            reassortmentsEl.innerHTML = `<a href="${workspaceFolder}${reassortmentsFilename}" target="_blank">${reassortmentsFilename}</a>`;
         }

         // Get a reference to the summary element.
         const summaryEl = document.getElementById("treesort_summary");
         if (summaryEl) { 
            // Populate the TreeSort summary HTML.
            summaryEl.innerHTML = treesortSummary;
         }

         // Populate the section with segment-specific results.
         populateResultsBySegment();
      }


      // Populate the section with segment-specific results.
      function populateResultsBySegment() {

         // Get a reference to the "results by segment" element.
         const resultsBySegmentEl = document.getElementById("treesort_segment_files");
         if (!resultsBySegmentEl) { return; }
            
         // Was segment data provided?
         if (!segments || segments.length < 1) { 
            resultsBySegmentEl.innerHTML = "No segments were analyzed";
            return;
         }
         
         let html = "";

         // Iterate over all segments that were included in the analysis.
         segments.forEach((segment_, index_) => {

            let rowsHTML = "";

            // Trim and validate the segment name.
            segment_ = segment_.trim();
            if (!segment_ || segment_.length < 1) { return; }

            // Try to get the segment summary from the JSON.
            const summaryHTML = getSegmentSummary(segment_);
            if (summaryHTML.length < 1) {
               html += `<div class="no-results">No data is available</div>`;
               return;
            }

            // Display the root-to-tip regression summary and PDF.
            html += `<h3 class="treesort--segment-title">${segment_} root-to-tip (RTT) regression</h3>
               <div class="treesort--section-body">
                  ${summaryHTML}
                  <div style="width: 640px; height: 480px;">
                     <embed src="${outputSubdirectory}/${segment_}-input.fasta.aln.treetime/root_to_tip_regression.pdf" type="application/pdf" width="100%" height="100%" />
                  </div>
               </div>`;
            
            // Create table rows for the linked files.
            segmentFiles.forEach((file_, index_) => {

               // Alternate row classes
               const rowClass = index_ % 2 ? "treesort--even" : "treesort--odd";

               const fileURL = `${workspaceFolder}${outputSubdirectory}/${segment_}${file_.path}`;

               // Create a row for this file.
               rowsHTML += `<tr class="${rowClass}">
                  <td><a href="${fileURL}" target="_blank">${segment_}${file_.path}</a></td>
                  <td>${file_.description}</td>
               </tr>`;
            })

            html += `<h3 class="treesort--segment-title">${segment_} files</h3>
               <table class="treesort--segment-table">
                  <thead>
                     <tr>
                        <th class="treesort--file">File</th>
                        <th>Description</th>
                     </tr>
                  </thead>
                  <tbody>${rowsHTML}</tbody>
               </table>`;
         })

         resultsBySegmentEl.innerHTML = html;
      }

      window.addEventListener('load', function() {
         populatePage();
      })
      
   </script>
</body>
</html>